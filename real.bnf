        |          1         2         3         4         5         6         7         8         9
        |0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
Parsing |Skip me ->{|. pos: 10. length: 1
Length of input: 1. Input |Skip me ->{|
Event                   Start     Span      Pos    Lexeme                  Comment             
Location: (1, 11). Lexeme: |{|. Next few chars: ||. Events: 1. Names: open_delim
open_delim                 10        1       11    {                       -                   
Warning: Ambiguous parse. Status: No parse. Terminals expected: open_delim, close_delim, text
Error: Parse failed
root. Attributes: {text => "", uid => "0"}
    |--- open. Attributes: {text => "{", uid => "1"}
Parse result: 1 (0 is success)

:default				::= action => [values]

lexeme default			= latm => 1

:start					::= input_text

input_text				::= input_string*

input_string			::= quoted_text
							| unquoted_text

quoted_text				::= open_delim input_text close_delim

unquoted_text			::= text

# Lexemes in alphabetical order.

delimiter_char			~ [{}]

:lexeme					~ close_delim		pause => before		event => close_delim
close_delim			~ [}]


escaped_char			~ '\' delimiter_char	# Use ' in comment for UltraEdit.

# Warning: Do not add '+' to this set, even though it speeds up things.
# The problem is that the set then gobbles up any '\', so the following
# character is no longer recognized as being escaped.
# Trapping the exception then generated would be possible.

non_quote_char			~ [^{}]	# Use " in comment for UltraEdit.

:lexeme					~ open_delim		pause => before		event => open_delim
open_delim			~ [{]


:lexeme					~ text				pause => before		event => text
text					~ escaped_char
							| non_quote_char
